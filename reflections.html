<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }

        header {
            background-color: #0044cc;
            color: white;
            padding: 20px 10%;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5em;
        }

        header p {
            margin: 10px 0 0;
            font-size: 1.2em;
        }

        nav {
            background-color: #333;
            color: white;
            display: flex;
            justify-content: center;
            padding: 10px 0;
        }

        nav a {
            color: white;
            text-decoration: none;
            margin: 0 15px;
            font-size: 1.1em;
        }

        nav a:hover {
            text-decoration: underline;
        }

        nav a.active {
            font-weight: bold;
            border-bottom: 2px solid #0044cc;
        }

        main {
            padding: 20px 10%;
        }

        section {
            margin-bottom: 20px;
        }

        section h2 {
            color: #0044cc;
        }

        footer {
            background-color: #222;
            color: white;
            text-align: center;
            padding: 10px 0;
            position: relative;
            bottom: 0;
            width: 100%;
        }

        footer p {
            margin: 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header>
        <h1>Course Learning Reflections</h1>
        <p>Insights and Takeaways from the Design and Analysis of Algorithms Course</p>
    </header>
    <nav>
        <a href="index.html">Home</a>
        <a href="index.html#project">Course Project Introduction</a>
        <a href="reflections.html" class="active">Course Learning Reflections</a>
    </nav>
    <main>
        <section id="reflections">
            <h2>Learning Reflections</h2>
            <ul>
                <li>What are the kinds of problems we see in nature? (iteration, recursion, backtracking)</li>
                <p>Iteration is often used for tasks that require repetitive actions, such as searching for a value in a list...</p>

                <li>What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth.</li>
                <p>Space efficiency refers to minimizing memory usage, while time efficiency focuses on reducing execution time...</p>

                <li>Takeaways from different design principles from Chapter 2 (can use the notes provided).</li>
                <p>Key principles include Divide and Conquer for breaking problems into smaller parts...</p>

                <li>The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, BST, AVL, 2-3, Red-Black, Heap, Trie).</li>
                <p>Trees represent hierarchical data like file systems...</p>

                <li>The need for array query algorithms and their implications. Their applications and principles need to be discussed.</li>
                <p>Array query algorithms like Segment Trees and Fenwick Trees provide efficient solutions...</p>

                <li>Differentiate between trees and graphs and their traversals. Discuss the applications of each.</li>
                <p>Trees are a type of graph without cycles...</p>

                <li>Deliberate on sorting and searching algorithms, the techniques behind each, and how they connect to the real world.</li>
                <p>Sorting algorithms like Quick Sort and Merge Sort organize data efficiently...</p>

                <li>Discuss the importance of graph algorithms concerning spanning trees and shortest paths.</li>
                <p>Graph algorithms like Kruskal's and Dijkstra's solve network optimization problems...</p>

                <li>Discuss the different studied algorithm design techniques.</li>
                <p>Brute force examines all possibilities...</p>
            </ul>
            <h2>Reflections on Problem-Solving and Design</h2>
            <p><strong>How do you determine the most efficient approach when solving a complex problem?</strong><br>
            To determine the most efficient approach, I analyze the problem's constraints, evaluate potential solutions, and choose based on time complexity, space requirements, and practicality. Testing with sample cases helps refine the chosen method.</p>

            <p><strong>Reflect on a situation where you need to balance multiple conflicting constraints in a design. What approach did you take?</strong><br>
            In such scenarios, I prioritize constraints based on their impact, trade-offs, and feasibility. I employ iterative testing to find a balanced solution that meets critical requirements while compromising on less crucial aspects.</p>

            <p><strong>What criteria do you use to evaluate the effectiveness of a solution?</strong><br>
            Effectiveness is evaluated based on correctness, efficiency, scalability, and user satisfaction. Ensuring the solution addresses all problem requirements is also critical.</p>

            <p><strong>How can you adapt an existing solution to address a new or unforeseen challenge?</strong><br>
            Adapting involves analyzing the new challenge, identifying similarities with the existing solution, and modifying or extending it to meet new requirements. This process often includes adding flexibility and modularity.</p>

            <p><strong>What strategies do you use to identify patterns or structures in complex datasets or problems?</strong><br>
            Strategies include visualizing data, exploring statistical correlations, and breaking the problem into smaller segments. Leveraging algorithms like clustering and pattern recognition also aids in identifying meaningful structures.</p>

            <p><strong>How do you decide when to prioritize simplicity over optimization in a solution?</strong><br>
            Simplicity is prioritized when the solution's clarity and maintainability outweigh the benefits of optimization, especially in cases with minimal performance differences or tight development timelines.</p>

            <p><strong>Reflect on how breaking down a problem into smaller components can help you approach it more effectively.</strong><br>
            Breaking down a problem allows for a focused approach on manageable segments. This strategy simplifies understanding, facilitates debugging, and enables parallel development of components.</p>

            <p><strong>Reflect on the trade-offs while choosing between different approaches to solve a problem.</strong><br>
            Trade-offs are assessed by comparing factors such as efficiency, scalability, complexity, and resource requirements. The choice depends on which factors align best with the problem's goals and constraints.</p>

            <p><strong>How do you identify and address potential limitations or weaknesses in a proposed solution?</strong><br>
            Limitations are identified through testing, peer reviews, and analyzing edge cases. Addressing them involves iterative refinement, incorporating feedback, and leveraging alternative approaches or technologies.</p>

            <p><strong>Reflect on how applying knowledge from one context can help you solve a problem in a different context.</strong><br>
            Applying knowledge from one context involves recognizing underlying principles and adapting them creatively. Cross-domain thinking enables innovative solutions and enhances problem-solving versatility.</p>

            <p><strong>How do you decide when to innovate versus relying on tried-and-tested solutions?</strong><br>
            The decision to innovate or rely on established solutions depends on the problem's complexity, risk tolerance, and resource availability. I opt for innovation when existing solutions fall short and reliability when proven methods suffice.</p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Design and Analysis of Algorithms. All rights reserved.</p>
    </footer>
</body>
</html>
